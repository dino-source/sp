#11.2 Ещё раз про указатели (pointers):

#1 Вопрос: что такое указатель (pointer)?
Ответ: указатель (pointer) - это переменная, которая в качестве значения хранит адрес другой переменной
Пример:
int cats = 4; // объявили переменную типа int по имени "cats" и инициализировали её значением 4
int *ptr = &cats; // объявили переменную типа int* (указатель на int) по имени ptr, которая в качестве значения хранит адрес переменной cats

#2 Вопрос: можно ли объявить указатель, который не указывает ни на что?
Ответ: можно.
Пример:
int *ptr; // объявили переменную типа int* (указатель на int) по имени ptr

#3 Вопрос: как лучше объявить указатель, если в момент объявления неизвестно, куда он будет указывать?
Ответ: лучше инициализировать такой указатель литералом nullptr
Пример:
int *ptr = nullptr; // объявили указатель и инициализировали его литералом nullptr

#4 Вопрос: как получить значение переменной, на которую указывает указатель?
Ответ: с помощью оператора разыменования указателя (pointer dereferencing).
Пример:
int cats = 4;
int *ptr = &cats;
std::cout << *ptr; // разыменовали указатель, чтобы вывести на экран значение 4

#5 Вопрос: как вывести на консоль адрес переменной, который наш указатель хранит в качестве значения?
Ответ: обратится к указателю по имени.
Пример:
int cats = 4;
int *ptr = &cats;
std::cout << ptr; // выводим на консоль адрес переменной cats

#6 Вопрос: как вывести на консоль адрес указателя?
Ответ: использовать оператор взятия адреса (address-of operator).
Пример:
int cats = 4;
int *ptr = &cats;
std::cout << &ptr; // выводим на консоль адрес указателя ptr

#7 Вопрос: можно ли разыменовать пустой указатель?
Ответ: можно, но так делать не надо; такое действие приводит к неопределённому поведению (undefined behavior)
Пример:
int *ptr = nullptr; // пустой указатель
std::cout << *ptr; // попытка разыменовать пустой указатель - undefined behavior [НЕ ДЕЛАЙТЕ ТАК!!!]

#8 Вопрос: зачем в С++ два таких похожих инструмента - ссылки и указатели?
Ответ: так исторически сложилось - указатели унаследованы из языка С, а ссылки появлись позже - это уже чисто плюсовый инструмент

#9 Вопрос: можно ли перенаправить указатель (заставить его указывать на другой объект)?
Ответ: можно.
Пример:
int cats = 4;
int *ptr = &cats; // указатель ptr указывает на переменную cats
int dogs = 5;
ptr = &dogs; // теперь указатель ptr указывает на переменную dogs

#10 Вопрос: как изменить значение переменной через указатель?
Ответ: использовать разыменование указателя и оператор присваивания.
Пример:
int cats = 3;
int *ptr = &cats; // указатель ptr указывает на переменную cats
*ptr = 7; // теперь в переменной cat лежит значение 7
std::cout << *ptr; // на консоль выведется 7
std::cout << cats; // на консоль выведется 7

#11 Вопрос: можно ли создать массив указателей?
Ответ: можно.
Пример:
std::vector<int*> collection_of_pointers_to_int; // объявили вектор указателей на int

#12 Вопрос: можно ли указатели использовать в качестве параметров функции?
Ответ: можно.
Пример:
#include <iostream>

void cube(int *number); // прототип функции cube, в качестве параметра - указатель на int

int main()
{
    int num = 3;
    cube(&num); // вызов функции cube - в качестве аргумента передаём адрес переменной num
    std::cout << num << '\n'; // 27
}

void cube(int *number) // определение функции cube, в качестве параметра - указатель на int
{
    *number = (*number) * (*number) * (*number);
}